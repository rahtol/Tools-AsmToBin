/**
 * JavaCC file for Intel Assembler syntax.
 */options{  JDK_VERSION = "1.5";
  LOOKAHEAD = 1;
  STATIC = false;}PARSER_BEGIN(ASMPARSER)
import java.io.File;
import java.io.FileReader;

public class ASMPARSER{
  final static String version = "AsmToBin v1.00, 21.12.2014";
  
  public String segmentname;
  public int offset;
    public static void main(String args []) throws ParseException  {    System.out.println(version);
    
    if (args.length < 2) {
        System.err.println ("usage: AsmToBin <Existing-ASM-InputFile> <Name-of-Generated-Binary-Outputfile>\n");
        System.exit(-1);
    };

    File infile = new File (args[0]);
    File outfile = new File (args [1]);
    System.out.println("Reading from: \"" + args[0] + "\"");
    System.out.println("Writing to: \"" + args [1] + "\"");

    try    {      ASMPARSER parser = new ASMPARSER(new FileReader(infile));
      switch (parser.asm_compilation_unit())      {        case 0 :         System.out.println("OK.");        break;        case 1 :         System.out.println("ERROR.");        default :         break;      }    }    catch (Exception e)    {      System.out.println("NOK.");      System.out.println(e.getMessage());    }    catch (Error e)    {      System.out.println("Oops.");      System.out.println(e.getMessage());    }  }}PARSER_END(ASMPARSER)SKIP :{  " "| "\r"| "\t"| "\n"|  < ";" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >
}TOKEN [IGNORE_CASE]: /* KEYWORDS */
{
  < NAME : "NAME" > 
| < SEGMENT : "SEGMENT" >
| < BYTE : "BYTE" >
| < USE32 : "USE32" >
| < RO : "RO" >
| < ALIGN : "ALIGN" >
| < ENDS : "ENDS" >
| < END : "END" >
| < DB : "DB" >
| < DW : "DW" >
| < DD : "DD" >
}

TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >}TOKEN :{  < CONSTANT : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >
| < IDENTIFIER : <LETTER> (<LETTER> | <DIGIT>)* >|  <#LETTER: ["$","A"-"Z","_","a"-"z"]>
}int asm_compilation_unit() :{}{
  name ()  (    segment()
  )+
  < END >
  < EOF >  {    return 0;  }}
void name() :
{}
{    < NAME > < IDENTIFIER >
}
void segment() :
{}
{
    segment_header_statement()
    (
      < ALIGN > < CONSTANT >
    )?
    (      LOOKAHEAD(2)
      data_statement()
    )+
    segment_ends_statement()
}

void segment_header_statement() :{}{    < IDENTIFIER >
    {
      segmentname = token.image;      offset = 0;
      System.out.println ("Start of Segment \"" + segmentname + "\"");
    }
    < SEGMENT > (segment_attribute())* 
}
void segment_ends_statement() :
{
  Token segname;
}
{
    segname = < IDENTIFIER >
    < ENDS >
    {
      if (!segname.image.equals(segmentname))
      {
        System.out.println ("Segment name mismatch: \"" + segname.image + "\"");
      }
      System.out.println("Segment \"" + segmentname + "\" Closed, len=" + offset);
    }
}
void segment_attribute() :
{}
{
    < BYTE >
  | < USE32 >
  | < RO >
}

void data_statement() :
{
  int ddlen;
}
{
    (      label()
    )?
    (      < DB >      {         ddlen = 1;
      }
    | < DW >
      {
         ddlen = 2;
      }
    | < DD >
      {
         ddlen = 4;
      }
    )
    expr()
    {      offset += ddlen;
    }
}

void label() :
{
  String label;
}
{
    < IDENTIFIER >    {      label = token.image;
    }
    ":"
    {      System.out.println("Define label \"" + label + "\" at offset " + offset);
    }
}

void expr() :
{}
{  term()
  (
    (
      < PLUS >
    | < MINUS >
    )
    term()
  )*
}

void term() :{}{  unary()  (    (      < MULTIPLY >    | < DIVIDE >    )    unary()  )*}void unary() :{}{  < MINUS > element()| element()}void element() :{}{  < CONSTANT >
| < IDENTIFIER >| "(" expr() ")"}
